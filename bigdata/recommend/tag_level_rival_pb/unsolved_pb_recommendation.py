# -*- coding: utf-8 -*-
"""unsolved_pb_recommendation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QhWAzbjGbnYOWKxW27xVIKtRM9ySi_h7
"""

import random
import pandas as pd
from scipy import sparse
import numpy as np

import warnings
warnings.filterwarnings("ignore")

class filter:
    def __init__(self,lst_rivals, profile2id, show2id):
        self.lst_rivals= lst_rivals
        self.profile2id= profile2id
        self.show2id= show2id

    def numerize_for_profile(self,x):
        return self.profile2id[x]

    def numerize_for_problem(self,x):
        return self.show2id[x]

    def extract_prob(self,x):
        target=set(x['target_prob'].split(','))
        rival= set(x['rival_prob'].split(','))
        result= rival - target
        if len(result) ==0:
            result= set(self.show2id.keys()) - target
            return random.sample(result, 1) #replace idx에 들어가도록
        return list(result)

    def filter_prob(self,df_problems_solved,target_users):
        tmp= self.lst_rivals.apply(lambda x: x.split(','))
        tmp= pd.DataFrame(tmp)
        tmp= list(tmp.similar_rivals)
        #라이벌 핸들 수치화
        tmp= pd.DataFrame(tmp)
        tmp[0]= tmp[0].apply(self.numerize_for_profile)
        tmp[1]= tmp[1].apply(self.numerize_for_profile)
        tmp[2]= tmp[2].apply(self.numerize_for_profile)
        tmp[3]= tmp[3].apply(self.numerize_for_profile)
        tmp[4]= tmp[4].apply(self.numerize_for_profile)
        tmp[5]= tmp[5].apply(self.numerize_for_profile)
        # 리스트 값으로 들어가도록 변환
        tmp= pd.DataFrame(tmp[[0,1,2,3,4,5]].apply(lambda row: list(row), axis=1))
        # 라이벌이 푼 문제들을 전부 합침
        rival_prob= tmp[0].apply(lambda x: ','.join(df_problems_solved.iloc[x]['problems']))
        only_prob= pd.DataFrame({'rival_prob':rival_prob})
        target_users= pd.DataFrame(target_users)
        target_users['handle']= target_users['handle'].apply(self.numerize_for_profile)
        target_prob=pd.DataFrame({'target_prob':df_problems_solved.iloc[target_users['handle']]['problems']})

        target_prob = target_prob.reset_index()
        only_prob = only_prob.reset_index()
        only_prob= pd.concat([target_prob, only_prob], axis=1)

        # 30s
        only_prob.dropna(inplace=True)
        only_prob= only_prob.apply(self.extract_prob, axis=1)
        only_prob= pd.DataFrame({'problems':only_prob,'handle':target_users['handle']})
        
        only_prob= only_prob.explode('problems').reset_index(drop=True)
        only_prob.dropna(inplace=True)
        only_prob['problems']= only_prob['problems'].astype('int')
        # problems numerize
        only_prob['problems']= only_prob['problems'].apply(self.numerize_for_problem)

        n_items= len(self.show2id)
        n_users= len(self.profile2id)

        rows, cols = only_prob['handle'], only_prob['problems']
        data = sparse.csr_matrix((np.ones_like(rows),
                                        (rows, cols)), dtype='float16',
                                        shape=(n_users, n_items))

        return data, only_prob

from google.colab import drive
drive.mount('/gdrive')

import pandas as pd
from scipy import sparse
import numpy as np
import pickle
import warnings
warnings.filterwarnings("ignore")

# file_path = '/content/drive/MyDrive/SSAFY/'
file_path = '/gdrive/My Drive/Colab Notebooks/SSAFY/dataRecommendation/'

def rm_comma(x):
    return ''.join(str(x).split(','))

def load_data():
    df_users = pd.read_csv(file_path + 'users.csv')  # 유저 데이터
    # 중복 유저 제거
    df_users = df_users.drop_duplicates(['handle'])
    df_problems = pd.read_csv(file_path + 'probleams_.csv')  # 문제 데이터
    df_problems_solved = pd.read_csv(file_path + 'user_solved_problems_fixed.csv')  # 유저별 푼 문제 데이터
    df_rec_rivals = pd.read_csv(file_path + 'similar_rival_knn.csv')  # 유저별 라이벌 데이터
    # df_problems = pd.read_sql('select * from problems', db)
    # df_problems_solved = pd.read_sql('select * from problems_solved', db)
    # df_users= pd.read_sql('select * from users',db)
    # df_problems_class= pd.read_sql('select * from problems_class',db)
    # df_rec_rivals = pd.read_sql('select * from recommend_rivals',db)

    # 전처리
    df_problems = df_problems[df_problems.is_solvable == True]
    df_problems['tags'].loc[df_problems.tags.isnull()] =''
    df_problems= df_problems[df_problems['level']!=0]

    df_problems_solved.drop(df_problems_solved[df_problems_solved.problems==''].index, axis=0, inplace=True)

    df_users= df_users[df_users.handle.isin(df_problems_solved.handle)]
    df_users= df_users[df_users.handle.isin(df_rec_rivals.handle)]
    df_users.drop(df_users[df_users.handle.isin(list(set(df_users[df_users.solved_count == 0].handle)-set(df_problems_solved.handle)))].index, axis=0, inplace=True)
    df_users= df_users[df_users.handle.isin(df_problems_solved.handle)]
    
    df_problems.reset_index(inplace=True,drop=True)
    df_problems_solved.reset_index(inplace=True,drop=True)
    df_users.reset_index(inplace=True,drop=True)

    return df_problems_solved, df_rec_rivals, df_problems

def numerize_for_infer(tp, profile2id, show2id):
    uid = tp['handle'].apply(lambda x: profile2id[x])
    sid = tp['problems'].apply(lambda x: show2id[x])
    return pd.DataFrame(data={'uid': uid, 'sid': sid}, columns=['uid', 'sid'])

def preprocess_rival_prob(df_problems_solved):
    ## 문제 id
    df_user_problems = df_problems_solved[['handle', 'problems']]
    df_user_problems.problems = df_user_problems.problems.str.split(',')
    df_user_problems = df_user_problems.explode('problems').reset_index(drop=True)

    # 빈칸 및 NaN 제거
    df_user_problems['problems'].replace('', np.nan, inplace=True)
    df_user_problems = df_user_problems.dropna()

    df_user_problems['problems']= df_user_problems['problems'].astype('int')
    df_user_problems = df_user_problems.dropna(axis=0)
    df_user_problems = df_user_problems[df_user_problems.problems != '']
    df_user_problems['problems']= df_user_problems['problems'].astype('int')
    df_user_problems = df_user_problems.dropna(axis=0)
    ##아이템 ID
    unique_sid = pd.unique(df_user_problems['problems'])
    show2id = dict((sid, i) for (i, sid) in enumerate(unique_sid))

    # profile id
    unique_uid = df_user_problems.handle.unique()
    profile2id = dict((pid, i) for (i, pid) in enumerate(unique_uid))

    infer_df = numerize_for_infer(df_user_problems, profile2id, show2id)
    # print(infer_df)
    n_items = infer_df['sid'].max()+1
    n_users = infer_df['uid'].max() + 1

    rows, cols = infer_df['uid'], infer_df['sid']
    data = sparse.csr_matrix((np.ones_like(rows),
    (rows, cols)), dtype='float64', shape=(n_users, n_items))


    return data, profile2id, show2id, df_user_problems

pip install implicit

import os
import numpy as np
import pandas as pd
import random
from scipy import sparse
from implicit.evaluation import *
from implicit.als import AlternatingLeastSquares as ALS
import pickle
# from preprocessing import load_data, preprocess_rival_prob
# from filtering import filter
# import torch
from sklearn.metrics.pairwise import cosine_similarity
import warnings
warnings.filterwarnings("ignore")

# file_path = '/content/drive/MyDrive/SSAFY/'
file_path = '/gdrive/My Drive/Colab Notebooks/SSAFY/dataRecommendation/'

def first_division(num):
    for i in range(2, num+1):
        if num % i == 0:
            return i
    return 1

def numerize_for_profile(x):
    return profile2id[x]
def numerize_for_problem(x):
    return show2id[x]

def main_mf_als():
    seed = 0
    global profile2id, show2id
    df_problems_solved, df_rec_rivals, df_problems = load_data()

    # 빈칸 및 NaN 제거
    df_problems_solved['problems'].replace('', np.nan, inplace=True)
    df_problems_solved = df_problems_solved.dropna()

    print('데이터 로드 완료!')
    lst_rivals= df_rec_rivals['similar_rivals']
    target_users= df_rec_rivals['handle']
    
    data, profile2id, show2id, df_user_problems= preprocess_rival_prob(df_problems_solved)

    with open(file_path + 'show2id.pkl','wb') as f:
        pickle.dump(show2id,f)
    with open(file_path + 'profile2id.pkl','wb') as f:
        pickle.dump(profile2id,f)

    print('데이터 전처리 완료!')
    f= filter(lst_rivals,profile2id, show2id) # 라이벌은 풀고 타겟유저는 안푼 문제에 대한 csr matrix
    check, df_only_prob= f.filter_prob(df_problems_solved, target_users)
    print('필터 완료!')
    # als 모델링
    # device= torch.device("cuda" if torch.cuda.is_available() else "cpu") 
    # if torch.cuda.is_available():
    #     use_gpu_value = True
    # else:
    #     use_gpu_value = False
    # #device = "cpu"
    # #use_gpu_value = False
    # print('DEVICE: ', device)
    # print("use_gpu_value: ", use_gpu_value)
    
    als_model = ALS(factors=7, regularization=0.01, iterations = 50, random_state=seed)
    als_model.fit(data)

    print('모델 학습 완료!')
    
    # 유사도 구할 행렬 
    # df_user_level 유저별로 상위 레벨(+유저가 많이 푼) 30개 문제 추출
    df_user_level= pd.merge(df_user_problems,df_problems[['problem_id','level','accepted_user_count']], right_on='problem_id', left_on='problems', how='left')
    df_user_level.fillna(0, inplace=True)
    df_user_level.drop(['problem_id'], axis=1, inplace=True)

    df_user_level= df_user_level.sort_values(['handle','level','accepted_user_count'], ascending=False)
    df_user_level.reset_index(inplace=True, drop=True)

    df_user_level['handle']= df_user_level['handle'].apply(numerize_for_profile)
    df_user_level['problems']= df_user_level['problems'].apply(numerize_for_problem)

    df_user_level= df_user_level.groupby('handle')[['handle','problems']].head(30)

    df_user_level= df_user_level.groupby('handle')['problems'].agg(list)
    df_user_level= pd.DataFrame(df_user_level)
    df_user_level.reset_index(inplace=True) # 유사도 구할 행렬

    # df_only_prob: 라이벌은 풀었지만 타겟유저는 풀지 않은 문제들
    df_only_prob= df_only_prob.groupby('handle')['problems'].agg(list)
    df_only_prob= pd.DataFrame(df_only_prob)
    df_only_prob.reset_index(inplace=True) # 유사도 구할 행렬

    df_sim= pd.merge(df_user_level, df_only_prob, on='handle')
    df_sim.rename({'problems_x': 'target_prob','problems_y':'rival_prob'}, axis=1, inplace=True)

    # 유사도 구하기
    print('유저에게 적합한 문제 추출 중...')

    item_f= als_model.item_factors
    def recommend_prob(x):
        if len(x['rival_prob']) <= 30:
            return x['rival_prob']
        cos=cosine_similarity(item_f[x['target_prob']],item_f[x['rival_prob']])
        cos= (-cos).argsort()
        col=0
        result= cos[:,col]
        result=list(set(result))
        
        while len(result) <30:
            col+=1
            lst= cos[:,col]
            lst= list(set(lst)-set(result))
            add= 30-len(result)
            try:
                result.extend(lst[:add])
            except:
                result.extend(lst)

        return result
        
    df_sim['rec_problems']= df_sim.apply(lambda x: recommend_prob(x), axis=1)
    # denumerize
    id2profile = dict((int(v), str(k)) for k, v in profile2id.items())
    id2item = dict((int(v), str(k)) for k, v in show2id.items())
    
    df_sim['handle']=df_sim['handle'].apply(lambda x: id2profile[x])
    df_sim['rec_problems']=df_sim['rec_problems'].apply(lambda x: list(map(lambda x: id2item[x], x)))

    result= df_sim[['handle','rec_problems']]
    result.rec_problems= result.rec_problems.apply(lambda x: (',').join(x))

    result.index += 1  #mysql에서 auto increment를 위해 1 추가
    result.index.name='id'

    print('라이벌 기반 문제 추천 완료!')
    result.to_csv(file_path + 'similar_rival_pb_mf_als_output.csv')

    return result


main_mf_als()